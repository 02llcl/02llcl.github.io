<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>暑假集训杭电第七场</title>
      <link href="/2021/08/11/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%83%E5%9C%BA/"/>
      <url>/2021/08/11/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%83%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="1003-Fall-with-Trees"><a href="#1003-Fall-with-Trees" class="headerlink" title="1003 Fall with Trees"></a>1003 Fall with Trees</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=990">题目链接</a></p><p>给定一个完全二叉树的形态求围成的面积</p><p>二叉树满足,父节点的横坐标为子节点的和的一半</p><p>推出每一层节点的长度套用O(1)的公式即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        base = base * base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;<span class="comment">//快速幂,不然会超时</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">double</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ss=<span class="number">4</span>*d*k<span class="number">-4</span>*d+<span class="number">4</span>*d*<span class="built_in">fastPower</span>(<span class="number">0.5</span>,k);</span><br><span class="line">   <span class="comment">// cout&lt;&lt;ss&lt;&lt;&quot;   !&quot;&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> ss;</span><br><span class="line">&#125;<span class="comment">//得到第n行</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">work</span><span class="params">(<span class="keyword">double</span> h,<span class="keyword">double</span> d,<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">double</span> d1=<span class="number">2</span>*d;</span><br><span class="line">     <span class="keyword">double</span> s=<span class="built_in">getsum</span>(k,d)+<span class="built_in">getsum</span>(k<span class="number">-1</span>,d)-d1;</span><br><span class="line">     s=s*h*<span class="number">1.0</span>/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">return</span> s;</span><br><span class="line">&#125;<span class="comment">//求答案</span></span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="1007-Link-with-Limit"><a href="#1007-Link-with-Limit" class="headerlink" title="1007 Link with Limit"></a>1007 Link with Limit</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1007&cid=990">题目链接</a></p><p>看似是数论,其实是一个图的建立,并其中的所有 环绝对值大小相等</p><p>&nbsp;&nbsp;</p><h3 id="1008-Smzzl-with-Greedy-Snake"><a href="#1008-Smzzl-with-Greedy-Snake" class="headerlink" title="1008 Smzzl with Greedy Snake"></a>1008 Smzzl with Greedy Snake</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1008&cid=990">题目链接</a></p><p>大模拟即可</p><p>&nbsp;&nbsp;</p><h3 id="1010-Smzzl-with-Tropical-Taste"><a href="#1010-Smzzl-with-Tropical-Taste" class="headerlink" title="1010  Smzzl with Tropical Taste"></a>1010  Smzzl with Tropical Taste</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1010&cid=990">题目链接</a></p><p>签到题</p><p>直接判断大小即可</p><p>&nbsp;&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第八场</title>
      <link href="/2021/08/10/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%85%AB%E5%9C%BA/"/>
      <url>/2021/08/10/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%85%AB%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>暴力出奇迹+阅读理解</p><p><img src="https://i.loli.net/2021/08/10/tYUsJgSuBDjahel.png" alt="image.png"></p><span id="more"></span><p>&nbsp;</p><h3 id="A-Ares-Toilet-Ares"><a href="#A-Ares-Toilet-Ares" class="headerlink" title="A Ares, Toilet Ares"></a>A Ares, Toilet Ares</h3><p><a href="https://ac.nowcoder.com/acm/contest/11259/A">题目链接</a></p><p>阅读理解题,题目意思太难看懂了</p><p>后面看懂了发现就直接求逆元模板即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=a*y%MOD;</span><br><span class="line">b=b*z%MOD;</span><br></pre></td></tr></table></figure><p><strong>一定要记得多求mod</strong></p><p>白wa好几发</p><p>&nbsp;</p><h3 id="E-Rise-of-Shadows"><a href="#E-Rise-of-Shadows" class="headerlink" title="E Rise of Shadows"></a>E Rise of Shadows</h3><p><a href="https://ac.nowcoder.com/acm/contest/11259/E">题目链接</a></p><p>签到题</p><p>开始想复杂了,质数一定也不是闰年直接输出no即可</p><p>&nbsp;</p><h3 id="K-Yet-Another-Problem-About-Pi"><a href="#K-Yet-Another-Problem-About-Pi" class="headerlink" title="K Yet Another Problem About Pi"></a>K Yet Another Problem About Pi</h3><p><a href="https://ac.nowcoder.com/acm/contest/11259/K">题目链接</a></p><p>一个长度为Π的线段最多经过几个格子</p><p>给定每个格子的长宽,易知只有斜线和走较小边有性价比</p><p>最开始想写背包的发现不得行</p><p>令 a=min{w,d}，b=√(w^2+d^2 )</p><p>算法无非是对 ax+by&lt;=pi 的非负解求 2x+3y 的最大值。</p><p>不难发现，<strong>x&lt;3 与 y&lt;2 至少有一成立</strong>，枚举后除法求解即可，注意精度问题。只需要枚举x&lt;3和y&lt;2即可</p><p>&nbsp;</p><h3 id="D-OR"><a href="#D-OR" class="headerlink" title="D OR"></a>D OR</h3><p><a href="https://ac.nowcoder.com/acm/contest/11259/D">题目链接</a></p><p>题意:给定两个数字b和c,满足:</p><p>bi=ai−1orai, ci=ai−1+ai</p><p>根据给定的数,输出a数组的可能性</p><p>分析:当时只想到枚举,没想到题解也是枚举不过要进行分开枚举</p><p>不过可以利用</p><p><img src="https://i.loli.net/2021/08/11/HkViWY2j4obqSGp.png" alt="image.png"></p><p>对第一个数二进制每一位进行枚举即可</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第七场</title>
      <link href="/2021/08/08/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%83%E5%9C%BA/"/>
      <url>/2021/08/08/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%83%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次比赛难度排名存靠签到))</p><p>pyf大佬带飞,难度差距有点大</p><span id="more"></span><p>&nbsp;&nbsp;</p><h3 id="I-xay-loves-or"><a href="#I-xay-loves-or" class="headerlink" title="I xay loves or"></a>I xay loves or</h3><p><a href="https://ac.nowcoder.com/acm/contest/11258/I">题目链接</a></p><p>签到题,看到or的时候就想到二进制,根据或的规则,判断各个位置</p><p>上的对应0,1即可,只有两个均为1的时候乘2.</p><p>题目翻译的时候漏注意了正整数第一次就wa了</p><p>只需特判(x==s)即可知道存不存在0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>||s&gt;<span class="number">0</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span>(s&amp;<span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span>(x&amp;<span class="number">1</span>) &#123;</span><br><span class="line">       ans&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(x&amp;<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">   s&gt;&gt;=<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;&nbsp;</p><h3 id="H-xay-loves-count"><a href="#H-xay-loves-count" class="headerlink" title="H xay loves count"></a>H xay loves count</h3><p><a href="https://ac.nowcoder.com/acm/contest/11258/H">题目链接</a></p><p>在一个队列中,寻找满足ai*ay=ak的个数</p><p>i,j,k可以改变顺序,可以相等</p><p>直接通过枚举双重for循环即可得到结果</p><p>通过桶排可以直接确定ak是否存在</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速幂模板</title>
      <link href="/2021/08/07/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
      <url>/2021/08/07/%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>快速幂的使用可以快速计算n次方的结果</p><p>只需要O(logn)即可</p><p>&nbsp;<span id="more"></span></p><p>&nbsp;</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fastPower</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base, <span class="keyword">long</span> <span class="keyword">long</span> power)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (power &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (power &amp; <span class="number">1</span>) &#123;<span class="comment">//此处等价于if(power%2==1)</span></span><br><span class="line">            result = result * base % <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        power &gt;&gt;= <span class="number">1</span>;<span class="comment">//此处等价于power=power/2</span></span><br><span class="line">        base = (base * base) % <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第六场</title>
      <link href="/2021/08/06/%E6%9D%AD%E7%94%B5%E7%AC%AC%E5%85%AD%E5%9C%BA/"/>
      <url>/2021/08/06/%E6%9D%AD%E7%94%B5%E7%AC%AC%E5%85%AD%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爆零++泪目,得好好内卷了))</p><p>这次难度上来,看群说比区域赛还难点</p><p>&nbsp;</p><span id="more"></span><p>&nbsp;</p><h3 id="1001-Yes-Prime-Minister"><a href="#1001-Yes-Prime-Minister" class="headerlink" title="1001 Yes, Prime Minister"></a>1001 Yes, Prime Minister</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&cid=989">题目链接</a></p><p>大意:给定你t组数据,每组一个x范围在±10e7,你需要给出</p><p>一个最小的区间(满足包含这个数的同时,区间和是一个质数)</p><p>常规解法就是埃氏筛,接着判断累和,容易tle</p><p>方法:</p><p>先预处理范围的所有质数,当区间为1的时候即可直接判断</p><p>利用等差公式,判断区间和为(l+r)(r-l+1)/2;也可以判断区间为2的情况</p><p>剩下的按照以下规则,分类讨论即可</p><p><img src="https://i.loli.net/2021/08/06/drFjzHBlRbTg4mc.png" alt="image.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">t=*<span class="built_in">lower_bound</span>(rec1.<span class="built_in">begin</span>(),rec1.<span class="built_in">end</span>(),x);<span class="comment">//找n后的第一个质数</span></span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*t);<span class="comment">//此时向左边增加</span></span><br><span class="line">t=*<span class="built_in">lower_bound</span>(rec2.<span class="built_in">begin</span>(),rec2.<span class="built_in">end</span>(),x);<span class="comment">//n后第一个2*z减一为质数</span></span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*t<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t=*<span class="built_in">lower_bound</span>(rec1.<span class="built_in">begin</span>(),rec1.<span class="built_in">end</span>(),-x+<span class="number">1</span>);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*t);</span><br><span class="line">t=*<span class="built_in">lower_bound</span>(rec2.<span class="built_in">begin</span>(),rec2.<span class="built_in">end</span>(),-x+<span class="number">2</span>);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="number">2</span>*t<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</strong></p><p>前面预处理时候,质数标记为1,故可以用lower_bound()来查找某个区间第一个质数</p><p>在于没想到区间的三种情况和lower_bound()函数的使用</p><p>&nbsp;</p><h3 id="1005-Median"><a href="#1005-Median" class="headerlink" title="1005 Median"></a>1005 Median</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?cid=989&pid=1005">题目链接</a></p><p>题解看蒙的有点懵,先码住</p><p><img src="https://i.loli.net/2021/08/07/Gknc8uAyFlJYrdO.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第五场</title>
      <link href="/2021/08/03/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%BA%94%E5%9C%BA/"/>
      <url>/2021/08/03/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%BA%94%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>(无)</p><p>&nbsp;</p><span id="more"></span><h3 id="1003-VC-Is-All-You-Need"><a href="#1003-VC-Is-All-You-Need" class="headerlink" title="1003 VC Is All You Need"></a>1003 VC Is All You Need</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1003&cid=988">题目链接</a></p><p>在n维空间最多可以分几类,范围过大</p><p>于是就规律题</p><p>m的最大值为n+1</p><p>判断即可</p><p>&nbsp;</p><h3 id="1006-Cute-Tree"><a href="#1006-Cute-Tree" class="headerlink" title="1006 Cute Tree"></a>1006 Cute Tree</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1006&cid=988">题目链接</a></p><p>根据题意的伪代码直接暴力输出tot即可</p><p>最开始想简单了,凑了几组数据就直接乘1.5了)))</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(r-l==<span class="number">1</span>)&#123;</span><br><span class="line">        tot+=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b=l+<span class="built_in">ceil</span>((r-l)*<span class="number">1.0</span>/<span class="number">3</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> c=<span class="built_in">floor</span>((b+r)*<span class="number">1.0</span>/<span class="number">2</span>);</span><br><span class="line">    work(l,b);</span><br><span class="line">    work(b+<span class="number">1</span>,c);</span><br><span class="line">    work(c+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接代入范围即可,输出tot.</p><p>&nbsp;</p><h3 id="1007-Banzhuan"><a href="#1007-Banzhuan" class="headerlink" title="1007 Banzhuan"></a>1007 Banzhuan</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?cid=988&pid=1007">题目链接</a></p><p>容易知道最大化代价为全部从最高处丢下铺满,</p><p><img src="https://i.loli.net/2021/08/04/HoZYStD8VdmQlk6.png" alt="image.png"></p><p><strong>利用1+2²+3²….+n²=n(n+1)(2n+1)/6</strong></p><p>*<em>和1+2+3+….+n=(n+1)<em>n/2</em></em></p><p>最小值为底面铺满,上面铺一个斜着的竖墙</p><p><img src="https://i.loli.net/2021/08/04/vpc45onjBl3yRQV.png" alt="image.png"></p><p>即可O(1)下得到结果</p><p>&nbsp;</p><h3 id="1004-Another-String"><a href="#1004-Another-String" class="headerlink" title="1004 Another String"></a>1004 Another String</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=988">题目链接</a></p><p>当时想到二维来进行O(n²)求答案了,可惜没想出怎么在O(n²)下完成前缀的准备</p><p>正解:定义 表示字符串 中分别以 为左端点的两个子串满足k-匹配的最大长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc_f</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> st=<span class="number">2</span>;st&lt;=n;++st)&#123;</span><br><span class="line">        <span class="keyword">int</span> dif=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,j=st,len=<span class="number">-1</span>; j&lt;=n; ++i,++j,--len)&#123;</span><br><span class="line">            <span class="keyword">while</span> (i+len+<span class="number">1</span>&lt;=n&amp;&amp;j+len+<span class="number">1</span>&lt;=n&amp;&amp;dif&lt;=k)&#123;</span><br><span class="line">                len++; </span><br><span class="line">                dif+=s[i+len]!=s[j+len];</span><br><span class="line">            &#125;</span><br><span class="line">            f[i][j]=len+(dif&lt;=k);<span class="comment">//是否超过k个</span></span><br><span class="line">            dif-=s[i]!=s[j];<span class="comment">//判断是否相同</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>len代表当前子串的长度,dif代表是否匹配,st代表第二个子串的左端点</strong></p><p>&nbsp;</p><p>接着就是统计每一行的总数得到对应结果</p><p>G[i,j]要取F[i,j]和两串之间长度的较小值,主要是线性完成预处理没想出</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第六场</title>
      <link href="/2021/08/02/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%85%AD%E5%9C%BA/"/>
      <url>/2021/08/02/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%85%AD%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>历史最佳))fn大佬%%%</p><img src="https://i.loli.net/2021/08/03/ZVhE5o8bJerk4fB.png" alt="image.png" style="zoom:80%;" /><p>&nbsp;</p><span id="more"></span><h3 id="I-Intervals-On-the-Ring"><a href="#I-Intervals-On-the-Ring" class="headerlink" title="I Intervals On the Ring"></a>I Intervals On the Ring</h3><p><a href="https://ac.nowcoder.com/acm/contest/11257/I">题目链接</a></p><p>题意:给出环上的一组区间，你需要构造环上的一组区间使得这些区间的交是给定的区间的并。</p><p>刚开始没懂,弄错了,其实只要取两两边界的左边跟上一个的右边就可以得到结果</p><p>&nbsp;</p><h3 id="F-Hamburger-Steak"><a href="#F-Hamburger-Steak" class="headerlink" title="F Hamburger Steak"></a>F Hamburger Steak</h3><p><a href="https://ac.nowcoder.com/acm/contest/11257/F">题目链接</a></p><p>题意:给出n个汉堡m个锅,汉堡允许拆开时间在两个锅,求最短耗时</p><p>分析:<strong>贪心</strong></p><p>时间有两个最大值可能(单个汉堡最大耗时,总时间除以m)</p><p>接着对每个时间段,依次按照汉堡顺序放入,如果剩余时间不够就放下一个</p><p>由于时间段长度大于最大值,则一定不会重复时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[p]&gt;=T) p++;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">if</span>(a[p]+t[i]&lt;=T)&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;1 &quot;</span>&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[p]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">      a[p]+=t[i];</span><br><span class="line">      cout&lt;&lt;a[p]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">if</span>(a[p]==T)p++; <span class="comment">//</span></span><br><span class="line">      <span class="keyword">continue</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分两半</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;2 &quot;</span>;</span><br><span class="line">    cout&lt;&lt;p+<span class="number">1</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;``<span class="string">&quot;0 &quot;</span>&lt;&lt;t[i]-(T-a[p])&lt;&lt;<span class="string">&#x27; &#x27;</span>; <span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;p&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[p]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;T&lt;&lt;endl; <span class="comment">//</span></span><br><span class="line">    </span><br><span class="line">    p++;</span><br><span class="line">    a[p]=t[i]-(T-a[p<span class="number">-1</span>]); <span class="comment">//</span></span><br><span class="line">    a[p<span class="number">-1</span>]=T; <span class="comment">//</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><h3 id="H-Hopping-Rabbit"><a href="#H-Hopping-Rabbit" class="headerlink" title="H Hopping Rabbit"></a>H Hopping Rabbit</h3><p><a href="https://ac.nowcoder.com/acm/contest/11257/H">题目链接</a></p><p>大意:</p><p>平面上有 n 个矩形，给定d，需要找到一个位置 (x,y)，</p><p>使得所有 (x+kd,y+kd) 均不落在矩形中</p><p>分析:</p><p><strong>扫描线＋线段树维护</strong>由于只能固定跳d长,可以将所有矩形通过求余,全部放进d*d中</p><p>假如(0,0)到(d,d)被完全覆盖,则没有点存在,否则存在</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快读模板</title>
      <link href="/2021/08/01/%E5%BF%AB%E8%AF%BB/"/>
      <url>/2021/08/01/%E5%BF%AB%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>某些毒瘤题会对,,,输入进行卡快读当然这就是模板,</p><p>只要背板子或者抄板子就可以.</p><p>&nbsp;</p><p>&nbsp;<span id="more"></span></p><h3 id="1-一般情况下"><a href="#1-一般情况下" class="headerlink" title="1.一般情况下"></a>1.一般情况下</h3><p>cin的读入速度在数据达到上百万的时候,速度会明显低于scanf和快读</p><p>scanf和快读的速度差别不是很大,大部分scanf即可,但有时候还是以防毒瘤(bushi)</p><p>稍微慢一点就过不去</p><p>&nbsp;</p><h3 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h3><p>就是利用读入字符的速度比读入数字快得多并且位运算的速度比平常更快</p><p>当然也存在字符串快读,实测整数快读可以通过更改int会为long long加大范围</p><p><strong>注意输入的时候有空格的时候不能用快读</strong></p><p>&nbsp;</p><h3 id="3-板子"><a href="#3-板子" class="headerlink" title="3.板子"></a>3.板子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">f</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">char</span> ch=getchar();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">f=<span class="number">-1</span>;</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);`</span><br><span class="line">ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">string</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="built_in">string</span> st1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> ((ch &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (ch &lt;= <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">        st1 += ch, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> st1;</span><br><span class="line">&#125;<span class="comment">//字符串快读str` </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>`</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">n=read();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第五场</title>
      <link href="/2021/07/31/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%BA%94%E5%9C%BA/"/>
      <url>/2021/07/31/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%BA%94%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>签到一题就罚坐了….泪目</p><p>第二题想复杂了,最后一题方法想出来了可是卡STL一直TLE心态崩了</p><p>&nbsp;&nbsp;</p><span id="more"></span><p>&nbsp;&nbsp;</p><h3 id="H-Holding-Two"><a href="#H-Holding-Two" class="headerlink" title="H Holding Two"></a>H Holding Two</h3><p><a href="https://ac.nowcoder.com/acm/contest/11256/H">题目链接</a></p><p>签到题</p><p>题目大意:给定长宽是否存在一个01矩阵不存在,连续的横竖斜长度为3的同线</p><p>不存在则输出-1</p><p>根据0101</p><p>​        0101</p><p>​        1010</p><p>​        1010 这样一直构造即可任意都存在</p><p>&nbsp;&nbsp;</p><h3 id="B-Boxes"><a href="#B-Boxes" class="headerlink" title="B Boxes"></a>B Boxes</h3><p><a href="https://ac.nowcoder.com/acm/contest/11256/B">题目链接</a></p><p>大意:确定随机的0,1盒子的最小期望</p><p>想复杂了…用前缀和计算每个位置的期望</p><p>开盒子的顺序并不影响,一定要先排序,从小到大开盒子.</p><p>只要使用一次询问一定是最开始.故有两种可能情况</p><p><strong>1.依次将所有开一遍</strong></p><p><strong>2.先询问一次,再一直开到后面为同色为止</strong></p><p>故ans=min(全部wi的和,C+每一种情况)</p><p>每一种即对应要确定第i个球时才能结束,概率为二分之一(n减i次方),前i个都为需要的</p><p>故</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ans += pre[i - 1] * pow(0.5, n - i + 1);</span><br><span class="line"> pre[i] = pre[i - 1] + a[i];</span><br></pre></td></tr></table></figure><p>pre代表确定前i的概率</p><p>&nbsp;</p><h3 id="K-King-of-Range"><a href="#K-King-of-Range" class="headerlink" title="K King of Range"></a>K King of Range</h3><p><a href="https://ac.nowcoder.com/acm/contest/11256/K">题目链接</a></p><p>寻找区间范围大于k的个数</p><p>1.ST表+双向指针(写了但会t)</p><p>2.两个单调队列,其中一个维护最小值的递增序列,一个维护最大值的最小序列</p><p>每次弹前面的那个,直到极差&lt;=k,后面也都满足;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">q1[t1]=q2[t2]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">      <span class="keyword">for</span>(;j&lt;=n &amp;&amp; a[q1[t1]]-a[q2[t2]]&lt;=k;)&#123;</span><br><span class="line">        ++j;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;n)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span>(;t1&lt;=w1 &amp;&amp; a[q1[w1]]&lt;=a[j];--w1);<span class="comment">//维护单调递减</span></span><br><span class="line">        q1[++w1]=j;</span><br><span class="line">        <span class="keyword">for</span>(;t2&lt;=w2 &amp;&amp; a[q2[w2]]&gt;=a[j];--w2);<span class="comment">//维护单调递增</span></span><br><span class="line">        q2[++w2]=j;</span><br><span class="line">      &#125;</span><br><span class="line">      ans += n+<span class="number">1</span>-j;</span><br><span class="line">      <span class="keyword">if</span>(q1[t1]==i)++t1;</span><br><span class="line">      <span class="keyword">if</span>(q2[t2]==i)++t2;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中set容器的常用方法</title>
      <link href="/2021/07/30/C++%20STL%20set/"/>
      <url>/2021/07/30/C++%20STL%20set/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>打算更新加复习一下一些STL容器的使用方法</p><p>先说set容器</p><span id="more"></span><p>&nbsp;</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>set是<a href="https://baike.baidu.com/item/C%2B%2B%E6%A0%87%E5%87%86%E5%BA%93/8795193">C++标准库</a>中的一种关联容器。所谓关联容器就是通过键（key）来读取和修改元素。与map关联容器不同，它只是单纯键的集合。**(来源百度百科)**</p><p>&nbsp;</p><h3 id="2-相关头文件及定义"><a href="#2-相关头文件及定义" class="headerlink" title="2.相关头文件及定义"></a>2.相关头文件及定义</h3><p>头文件：#include<set>;</p><p>定义:set&lt;数据类型&gt; 名称;</p><p>&nbsp;</p><h3 id="3-特性"><a href="#3-特性" class="headerlink" title="3.特性"></a>3.特性</h3><p>set容器可以达到自己去重的容器即插入相同元素只会保存一个</p><p><strong>也可以通过改变定义保存重复元素(multiset&lt;数据类型&gt; 名称)</strong></p><p>关于set容器的访问,set容器只能使用迭代器iterator访问</p><p>定义: <strong>set<int>::iterator it;</strong></p><p>常用的使用语句:</p><p>set<int> s;</p><p>s.insert(x); 将x插入set容器内</p><p>s.clear();将set容器清空</p><p>s.begin();返回set容器的第一个元素</p><p>s.end();返回set容器的最后一个元素</p><p>s.empty();判断set容器是否为空</p><p>s.erase();删除一个元素(注:相同元素也会被删除)</p><p>s.count(x);返回容器内等于x的个数</p><p>s.find(x);在容器中返回x的位置,不存在就返回s.end();</p><p>&nbsp;</p><h3 id="4-默认排序与初始化"><a href="#4-默认排序与初始化" class="headerlink" title="4.默认排序与初始化"></a>4.默认排序与初始化</h3><p>set容器属于关联式容器,用二叉树实现,默认排序为升序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">set&lt;int&gt; s;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  set&lt;int &gt; seta; //默认是小于比较器less&lt;int&gt;的set`</span><br><span class="line"></span><br><span class="line">   set&lt;int, greater&lt;int&gt; &gt; setb; //创建一个带大于比较器的set，需包含头文件functional</span><br><span class="line"></span><br><span class="line"> int a[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line"> set&lt;int &gt; setc(a,a+5); //数组a初始化一个set；</span><br><span class="line"></span><br><span class="line"> set&lt;int &gt; setd(setc.begin(),setc.end()); //setc初始化一个set</span><br><span class="line">       //上述两例均为区间初始化</span><br><span class="line"></span><br><span class="line">set&lt;int &gt; sete(setd); //拷贝构造创建set</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以自己定义排序方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">#include &lt;functional&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator () (const int &amp;a, const int &amp;b)&#123;</span><br><span class="line">        return a &gt; b;//可自己定义</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;int, cmp&gt;s; //自定义排序函数构造set</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第四场</title>
      <link href="/2021/07/29/%E6%9D%AD%E7%94%B5%E7%AC%AC%E5%9B%9B%E5%9C%BA/"/>
      <url>/2021/07/29/%E6%9D%AD%E7%94%B5%E7%AC%AC%E5%9B%9B%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>pyf大佬不在的第一天想他%%%</p><p>这次开题速度还好,A题我把函数转换弄错了,有两个函数,所以全为发散wa了两发</p><p>第二题也是比较明显的dfs,回溯每种类型数量的时候忘记了,多wa了两发</p><p>剩下就是签到罚坐了</p><span id="more"></span><p>&nbsp;</p><h3 id="1001-Calculus"><a href="#1001-Calculus" class="headerlink" title="1001 Calculus"></a>1001 Calculus</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&cid=987">题目链接</a></p><p>签到题</p><p>大意:判断一个函数是不是收敛函数</p><p>利用收敛函数相加为收敛,收敛加发散函数为发散</p><p>由于其中有两个函数替换</p><p><img src="https://i.loli.net/2021/07/30/FGmBz4QvNZYU62g.png" alt="image.png"></p><p>根据其给出的输入函数fi(x)中全为发散,故只有函数为0是收敛</p><p>&nbsp;</p><p>&nbsp;&nbsp;</p><h3 id="1002-Kanade-Loves-Maze-Designing"><a href="#1002-Kanade-Loves-Maze-Designing" class="headerlink" title="1002 Kanade Loves Maze Designing"></a>1002 Kanade Loves Maze Designing</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1002&cid=987">题目链接</a></p><p>题目大意:给定你一张连通图,两两点之间找到不一样权值的点个数再利用公式计算即可</p><p>dfs,写的时候忘记回溯了….</p><p>代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define MAXN 19560929</span><br><span class="line">#define MOD1 1000000007</span><br><span class="line">#define MOD2 1000000009</span><br><span class="line">using namespace std;</span><br><span class="line">int t,n,v[2001],num[2001],vv[2001];</span><br><span class="line">int A[2001][2001];</span><br><span class="line">vector&lt;int&gt; G[2001];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) G[i].clear();</span><br><span class="line">    for(int i=1;i&lt;=n-1;i++)&#123;</span><br><span class="line">        int a;</span><br><span class="line">        cin&gt;&gt;a;</span><br><span class="line">        G[i+1].push_back(a);</span><br><span class="line">        G[a].push_back(i+1);</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=n;i++) &#123;cin&gt;&gt;v[i];&#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;//输入</span><br><span class="line">long long work(int k,long long mod)</span><br><span class="line">&#123;</span><br><span class="line">    long long sum=0,d=1;</span><br><span class="line">    for(int j=1;j&lt;=n;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(j!=1) d=(d*MAXN)%mod;</span><br><span class="line">        sum=(sum+d*A[k][j])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;//计算</span><br><span class="line">void dfs(int st,int k,int nn,int num1[2001])</span><br><span class="line">&#123;</span><br><span class="line">    vv[k]=1;</span><br><span class="line">    if(num1[v[k]]==0)&#123;</span><br><span class="line">        nn++;</span><br><span class="line">    &#125;//如果这个点权值没出现</span><br><span class="line">    num1[v[k]]++;</span><br><span class="line">    A[st][k]=nn;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;G[k].size();i++)&#123;</span><br><span class="line">        int tt=G[k][i];</span><br><span class="line">        if(vv[tt]==0)&#123;</span><br><span class="line">        dfs(st,tt,nn,num1);</span><br><span class="line">        num1[v[tt]]--;//回溯回溯回溯</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        for(int i=1;i&lt;=n;i++) &#123;</span><br><span class="line">        memset(num,0,sizeof(num));</span><br><span class="line">        memset(vv,0,sizeof(vv));</span><br><span class="line">        num[v[i]]++;    </span><br><span class="line">        dfs(i,i,1,num);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       // for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        //    for(int j=1;j&lt;=n;j++)&#123;</span><br><span class="line">        //        cout&lt;&lt;A[i][j]&lt;&lt;&quot; &quot;;</span><br><span class="line">        //    &#125;</span><br><span class="line">        //    cout&lt;&lt;endl;</span><br><span class="line">        //&#125;</span><br><span class="line">        for(int i=1;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">                cout&lt;&lt;work(i,MOD1)&lt;&lt;&quot; &quot;&lt;&lt;work(i,MOD2)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;</p><h3 id="1009-License-Plate-Recognition"><a href="#1009-License-Plate-Recognition" class="headerlink" title="1009 License Plate Recognition"></a>1009 License Plate Recognition</h3><p>大意:输入一个车牌号,将每个数字字母或汉字的左右边界输入即可</p><p>方法:使用扫描线原理即可,记得特判最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int t,d;</span><br><span class="line">char s[40][110];</span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=30;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;=100;j++)&#123;</span><br><span class="line">            cin&gt;&gt;s[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">int c(int k)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=1;i&lt;=30;i++)&#123;</span><br><span class="line">        if(s[i][k]==&#x27;#&#x27;) return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int work(int left,int right)</span><br><span class="line">&#123;</span><br><span class="line">    if(left==0 || right==0) return 0;</span><br><span class="line">    if(d==0 &amp;&amp; right-left&lt;=9) return 0;</span><br><span class="line">    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;endl;</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    int tap=1;</span><br><span class="line">    while(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;tap&lt;&lt;&quot;:&quot;&lt;&lt;endl;</span><br><span class="line">        tap++;</span><br><span class="line">        d=0;</span><br><span class="line">        int left=0,right=0,ll=1;</span><br><span class="line">        while(ll&lt;=100)</span><br><span class="line">        &#123;</span><br><span class="line">            if(c(ll)==0 || ll==100)&#123;</span><br><span class="line">                if(ll==100 &amp;&amp; c(ll)==0) right=99;</span><br><span class="line">                if(ll==100 &amp;&amp; c(ll)==1) right=100;</span><br><span class="line">                if(work(left,right)==1)&#123;</span><br><span class="line">                    left=0;right=0;d++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                if(left==0) left=ll;</span><br><span class="line">                else right=ll;</span><br><span class="line">            &#125;</span><br><span class="line">            ll++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;</p><h3 id="1008-Lawn-of-the-Dead"><a href="#1008-Lawn-of-the-Dead" class="headerlink" title="1008 Lawn of the Dead"></a>1008 Lawn of the Dead</h3><p>大意:从图像左上角走,只能左转右转可以到达的位置</p><p>分析:原本第一眼以为是签到题,后面发现数据有1e5,,,不能二维dp就没想法了</p><p>题解:</p><p>计算不能到达的位置,用总数减,对地雷的行数排序,从上往下遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;`</span><br><span class="line">using namespace std;`</span><br><span class="line">typedef long long ll;`</span><br><span class="line">typedef pair&lt;int, int&gt; P;`</span><br><span class="line">typedef const int cint;`</span><br><span class="line">const int MAXN = 1e5 + 5;`</span><br><span class="line">`const int INF = 0x3f3f3f3f;`</span><br><span class="line">`const ll MOD = 1e9 + 7;`</span><br><span class="line">`#define For(i,j,k) for(int i=(int)(j);i&lt;=(int)(k);i++)`</span><br><span class="line">`#define Rep(i,j,k) for(int i=(int)(j);i&gt;=(int)(k);i--)`</span><br><span class="line">`#define debug(x) cout &lt;&lt; (x) &lt;&lt; &#x27;\n&#x27;`</span><br><span class="line">`#define fi first`</span><br><span class="line">`#define se second`</span><br><span class="line"></span><br><span class="line">`int n, m, k;`</span><br><span class="line">`set&lt;int&gt; s[MAXN];  // 每行的雷的位置`</span><br><span class="line">`vector&lt;P&gt; p[MAXN]; // 每行的有效区间`</span><br><span class="line">`inline void run()&#123;`</span><br><span class="line">  `cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;`</span><br><span class="line">  `For(i, 1, n) &#123;`</span><br><span class="line">    `s[i].clear();`</span><br><span class="line">    `p[i].clear();`</span><br><span class="line">  `&#125;`</span><br><span class="line">  `int x, y;`</span><br><span class="line">  `For(i, 1, k) &#123;`</span><br><span class="line">    `cin &gt;&gt; x &gt;&gt; y;`</span><br><span class="line">    `s[x].insert(y);`</span><br><span class="line">  `&#125;`</span><br><span class="line">  `For(i, 1, n) &#123;`</span><br><span class="line">    `s[i].insert(0);`</span><br><span class="line">    `s[i].insert(m+1);`</span><br><span class="line">  `&#125;`</span><br><span class="line">  `s[1].erase(s[1].begin());`</span><br><span class="line">  `p[1].push_back(P(1, *s[1].begin()-1));</span><br><span class="line">  For(i, 1, n-1) &#123;</span><br><span class="line">    for(P pi : p[i]) &#123;</span><br><span class="line">      int l = pi.fi, r = pi.se, L, R;</span><br><span class="line">      while((L=*s[i+1].begin()) &lt; r) &#123;`</span><br><span class="line">        `s[i+1].erase(s[i+1].begin());`</span><br><span class="line">        `R = *s[i+1].begin();`</span><br><span class="line">        `if(L+1==R || R &lt;= l) continue;`</span><br><span class="line">        `L = max(L, l-1);`</span><br><span class="line">        `p[i+1].push_back(P(L+1, R-1));`</span><br><span class="line">      `&#125;`</span><br><span class="line">    `&#125;`</span><br><span class="line">  `&#125;`</span><br><span class="line">  `ll res = 0;`</span><br><span class="line">  `For(i, 1, n) &#123;`</span><br><span class="line">    `for(P pi : p[i]) &#123;`</span><br><span class="line">      `res += pi.se - pi.fi + 1;`</span><br><span class="line">      `// cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; pi.fi &lt;&lt; &#x27; &#x27; &lt;&lt; pi.se &lt;&lt; &#x27;\n&#x27;;`</span><br><span class="line">    `&#125;`</span><br><span class="line">  `&#125;`</span><br><span class="line">  `debug(res);`</span><br><span class="line">`&#125;`</span><br><span class="line">`int main()&#123;`</span><br><span class="line">  `ios_base::sync_with_stdio(false);`</span><br><span class="line">  `cin.tie(nullptr), cout.tie(nullptr);`</span><br><span class="line"></span><br><span class="line">  `int T; for(cin &gt;&gt; T; T--;)`</span><br><span class="line">  `run(); return 0;`</span><br><span class="line">`&#125;`</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第三场</title>
      <link href="/2021/07/27/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%89%E5%9C%BA/"/>
      <url>/2021/07/27/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%89%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>感觉hdu的难度比牛客难多了</p><p>这次签到两题就下班了,好在没爆零…</p><span id="more"></span><p>&nbsp;</p><h3 id="1011-Segment-Tree-with-Pruning"><a href="#1011-Segment-Tree-with-Pruning" class="headerlink" title="1011 Segment Tree with Pruning"></a>1011 Segment Tree with Pruning</h3><p><a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1011&cid=986">题目链接</a></p><p>根据题目给定的n,k,和线段树的定义计算能生存的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node* build(long long l, long long r) &#123;</span><br><span class="line">    Node* x = new(Node);</span><br><span class="line">    if (r - l + 1 &lt;= k) return x;</span><br><span class="line">    long long mid = (l + r) / 2;</span><br><span class="line">    x -&gt; lchild = build(l, mid);</span><br><span class="line">    x -&gt; rchild = build(mid + 1, r);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由这个可知,生成结点的个数只有在r-l+1&lt;=k时才不会继续生成</p><p>由n/k可以得到最底下一层的个数,利用二叉树的性质即可以算出总数</p><p>假如不为完全二叉树,则加上下面一层多出来的即可</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="1007-Photoshop-Layers"><a href="#1007-Photoshop-Layers" class="headerlink" title="1007 Photoshop Layers"></a>1007 Photoshop Layers</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1007&cid=986">Problem - 1007 (hdu.edu.cn)</a>)</p><p>前缀和＋模拟即可</p><p>其中有个小知识点就是利用scanf直接进行16进制的输入</p><p><strong>scanf(“%x”,&amp;),可以用来读入十六进制整数</strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id="1004-Game-on-Plane"><a href="#1004-Game-on-Plane" class="headerlink" title="1004 Game on Plane"></a>1004 Game on Plane</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1004&cid=986">Problem - 1004 (hdu.edu.cn)</a>)</p><p>由题知两条直线只有在不平行的时候才存在交点</p><p>所以可以存储下斜率,每次从斜率次数最多和剩下出现次数最少的中取</p><p>然后计算即可得到结果</p><p>因为不能去重所以使用pair的数据结构来储存每个直线横纵坐标的差值</p><p>然后进行排序统计每个斜率的数量</p><p>最优策略就是最小 化斜率出现次数的最大值，所以不断从每种斜率的直线中各选一种即可。</p><h3 id="1009-Rise-in-Price"><a href="#1009-Rise-in-Price" class="headerlink" title="1009 Rise in Price"></a>1009 Rise in Price</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1009&cid=986">Problem - 1009 (hdu.edu.cn)</a>)</p><p>题目大意:</p><p>从(1,1)走到(n,n),每个位置可以获得钻石同时提高钻石价格</p><p>当时看到这题就感觉是个dp,然后发现没这么简单</p><p>&nbsp;</p><p>题解:</p><p>三维dp 用F(i,j,k)来表示走到(i,j)时,且一共收集了k个钻石时,单价最高多少</p><p>ans=max(每一个k下的最高单价)</p><p>关于时间复杂度其中进行合理优化,当某个位置总数少同时单价少时直接剔除</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第四场</title>
      <link href="/2021/07/26/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%9B%9B%E5%9C%BA/"/>
      <url>/2021/07/26/%E7%89%9B%E5%AE%A2%E7%AC%AC%E5%9B%9B%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次一共四个签到题,都签到完了不过错误次数有点多,开头卡在F题题意没懂,</p><p>白白wa了两发,J题读懂化简题目,可这最大平均子序列我自己写过都忘记了..</p><p>&nbsp;&nbsp;</p><span id="more"></span><h3 id="C-LCS"><a href="#C-LCS" class="headerlink" title="C.LCS"></a>C.LCS</h3><p><a href="https://ac.nowcoder.com/acm/contest/11255/C">题目链接</a></p><p>给定你三个字符串的长度,及两两之间相同字符的数量</p><p>分别为a,b,c,n</p><p>思路:</p><p>容易得到证明当前a,b,c中的两个较大值减去最小值大于等于n时存在</p><p>接着可以进行模拟得到字符串</p><p>(先放最小的,再放次小,接着放最大的即可)</p><p>&nbsp;</p><h3 id="F-Just-a-joke"><a href="#F-Just-a-joke" class="headerlink" title="F.Just a joke"></a>F.Just a joke</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11255/F">F-Just a joke_2021牛客暑期多校训练营4 (nowcoder.com)</a>)</p><p>当时被这道题卡了有点久,主要是题目中第二种操作到底是怎么删没看太懂</p><p>还是英文太差了.</p><p>由题解知道:第二种操作是能删点和线,也就是k个点和k-1个线</p><p>第一种和第二种操作都是减少奇数,故答案只跟n+m的奇偶有关</p><p>&nbsp;</p><h3 id="J-Average"><a href="#J-Average" class="headerlink" title="J. Average"></a>J. Average</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11255/J">J-Average_2021牛客暑期多校训练营4 (nowcoder.com)</a>)</p><p>给你两个序列a,b及其中的权值,根据Wi,j=ai+bj.可以得到一个边长为n*m的矩阵W</p><p>要得到平均值最大的一个矩阵行数大于x,列数大于y</p><p>根据式子化简可知要求a,b的最大平均子序列.</p><p><img src="https://i.loli.net/2021/07/27/y86P2AsJSN9bjkt.png" alt="image.png"></p><p>&nbsp;</p><h3 id="I-Inverse-Pair"><a href="#I-Inverse-Pair" class="headerlink" title="I. Inverse Pair"></a>I. Inverse Pair</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11255/I">I-Inverse Pair_2021牛客暑期多校训练营4 (nowcoder.com)</a>)</p><p>题目大意:</p><p>给定一个序列长度n,和权值ai,你可以给其中任意几个数加上1,使加上后其中的逆序对最少</p><p>只要在输入的时候记录下个数即可,总数减去可以减少的数量得到答案</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第三场</title>
      <link href="/2021/07/24/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E5%9C%BA/"/>
      <url>/2021/07/24/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%89%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>爆零爆零…数论还是有点弱今天的签到题都是数学方面确实不会太菜了</p><p>首次爆零(((</p><span id="more"></span><h3 id="J-Counting-Triangles"><a href="#J-Counting-Triangles" class="headerlink" title="J Counting Triangles"></a>J Counting Triangles</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11254/J">J-Counting Triangles_2021牛客暑期多校训练营3 (nowcoder.com)</a>)</p><p>大意:给定一个节点数n,和生存随机数的方法,将n点的完全无向图每条边</p><p>随机生成0或1,统计其中的全0或全1三元环</p><p>&nbsp;</p><p>方法: </p><p>一共只存在两种三角形,一种是全0全1,一种是两0一1和两1一0,第二种中一定存在</p><p>一个点到两个点的权值不同,故可以利用组合数计算出总数即Cn(3)</p><p>然后减去异色角数除以2即可得到答案</p><p><img src="https://i.loli.net/2021/07/25/EAST7VbdNLz2lQM.png" alt="image.png"></p><p>x统计1的个数,则0的个数为n-x-1,相匹配即相乘</p><p>最后计算即可得到结果</p><p>&nbsp;</p><h2 id="B题-Black-and-white"><a href="#B题-Black-and-white" class="headerlink" title="B题 Black and white"></a>B题 Black and white</h2><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11254/B">B-Black and white_2021牛客暑期多校训练营3 (nowcoder.com)</a>)</p><p>大意:给定一个矩形的长宽,和生成每个位置权值的公式</p><p>A0 = a<br>        A(i+1) = (Ai * Ai * b + Ai * c + d)% p</p><p>题解:</p><p>将每个位置看成一个连通块,当所有行列放在一个连通块时即可</p><p>得到答案最小值.</p><p>(故使用: 并查集+最小生成树)</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第二场</title>
      <link href="/2021/07/22/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
      <url>/2021/07/22/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次感觉题目有点难,签到都没签出来,通过率到不低,不过签到速度倒挺快的)</p><span id="more"></span><h3 id="1001-I-love-cube"><a href="#1001-I-love-cube" class="headerlink" title="1001: I love cube"></a>1001: I love cube</h3><p>(签到题)没写出来有点可惜</p><p>题目翻译:在一个边长为n的立方体中选三个点找可以组成等边三角形的数量个数</p><p>Input</p><p>The first line contains an integer T(T&lt;=1e5) . Then T test cases follow.</p><p>Each test case contains a single Integer n(0&lt;=n&lt;=1e18).</p><p>If n=0, output 0</p><p>Output</p><p>For each case, print an integer, which is the answer modulo 109+7</p><p>&nbsp;</p><p>分析:</p><p>多组数据同时n的范围比较大,只可能是O(1)的复杂度故知,应该是公式计算</p><p>对边长计算,当i为1的正方体内含有8个,边长为2就含有2的三次方个正方形,同理</p><p>i为2的正方体也是8个,</p><p>&nbsp;</p><p>依次可知:任意n,可拆成1,2,3…n-1长度的三角形故:</p><p><img src="https://i.loli.net/2021/07/23/lT2yJ8PiGfSw4nQ.png" alt="image.png"></p><p>&nbsp;</p><h3 id="1004-I-love-string"><a href="#1004-I-love-string" class="headerlink" title="1004 I love string"></a>1004 I love string</h3><p>(签到题)</p><p>找到一个能使字典序最小的序列的次数,每个字母只能放开头或结尾</p><p>给定你字母放置的顺序</p><p>&nbsp;</p><p>易知当前后字母不一样的时候,放法是固定的,故只需要看当前字符串前n个相同的个数</p><p>即可,记得求余</p><p>&nbsp;</p><h3 id="1012-I-love-114514"><a href="#1012-I-love-114514" class="headerlink" title="1012 I love 114514"></a>1012 I love 114514</h3><p>(签到题)</p><p>匹配字符串”114514”是否存在,输出对应结果即可</p><p>&nbsp;</p><h3 id="1008-I-love-exam"><a href="#1008-I-love-exam" class="headerlink" title="1008 I love exam"></a>1008 I love exam</h3><p>dp背包问题,先对每门课单独dp,然后再统一dp,</p><p>&nbsp;</p><h3 id="1010-I-love-permutation"><a href="#1010-I-love-permutation" class="headerlink" title="1010 I love permutation"></a>1010 I love permutation</h3><p>&nbsp;</p><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1010&cid=985">Problem - 1010 (hdu.edu.cn)</a>)</p><p>给你一个p代表项数,a为倍数,找ax%p后的余数对应的逆序数答案求余2</p><p>刚开始通过率还比较乐观,以为是中等题,由于p为1到10*e18</p><p>暴力打了一些数据,想看看能不能找到依据结果都没</p><p>题解:<strong>求排列的逆序对数对2取模的值，相当于求这个排列的奇偶 性。</strong> </p><p>求</p><p>&nbsp;</p><h3 id="1002码住下次补"><a href="#1002码住下次补" class="headerlink" title="1002码住下次补"></a>1002码住下次补</h3>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训杭电第一场</title>
      <link href="/2021/07/20/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
      <url>/2021/07/20/%E6%9D%AD%E7%94%B5%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>写完杭电的比赛,感觉杭电的题目稍微更能看懂,容易理解,就是不好想出正解</p><p>这次一共a了三题有点难,不过补题的思路也更明确</p><span id="more"></span><h3 id="1001"><a href="#1001" class="headerlink" title="1001"></a>1001</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1001&cid=984">Problem - 1001 (hdu.edu.cn)</a>)</p><p>签到题</p><p>&nbsp;</p><h6 id="翻译"><a href="#翻译" class="headerlink" title="翻译:"></a>翻译:</h6><p>给定一个整数n。</p><p>你需要计算(n mod 1)或(n mod 2)或…或者(n mod (n - 1))或者(n mod n)</p><p>“或”操作意味着“位或”。</p><p>&nbsp;</p><h6 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h6><p>原本想思考,后面直接打表找规律就A了</p><p>&nbsp;</p><h3 id="1005"><a href="#1005" class="headerlink" title="1005"></a>1005</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1005&cid=984">Problem - 1005 (hdu.edu.cn)</a>)</p><h6 id="翻译-1"><a href="#翻译-1" class="headerlink" title="翻译:"></a>翻译:</h6><p> 给n-1个点,找形成一个最小生成树的最小权值</p><p>原本以为lcm(a,b)为ab中更大的整数(垃圾翻译)没写出来刚开始</p><p>后面才知道是最小公倍数,用dp思想很快就知道了</p><h6 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a>分析:</h6><p>假设每新加第k个点要跟前面k-1个点连接,假如k不是质数则</p><p>前k-1一定存在k的因数,就可以构成最小的lcm,即k本身,假如k为质数,</p><p>k和任意数的最小公倍数,就是两数相乘,故将k和2连接即可</p><h6 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h6><p>用欧拉筛筛出所有质数,然后利用前缀和计算即可</p><p>每次输出对应的sum(n)就行</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="1008"><a href="#1008" class="headerlink" title="1008"></a>1008</h3><p>[题目链接](<a href="https://acm.hdu.edu.cn/contests/contest_showproblem.php?pid=1008&cid=984">Problem - 1008 (hdu.edu.cn)</a>)</p><h6 id="翻译-2"><a href="#翻译-2" class="headerlink" title="翻译:"></a>翻译:</h6><p>给你一个矩阵找到最大的每列不递减的子矩阵</p><h6 id="分析-2"><a href="#分析-2" class="headerlink" title="分析:"></a>分析:</h6><p>输入的时候将当前位置是否大于上一位来转化为0,1矩阵</p><p>然后求最大的全1矩阵即可</p><h6 id="解法-1"><a href="#解法-1" class="headerlink" title="解法::"></a>解法::</h6><p>利用栈将01转换成矩形条来依次计算</p><p><img src="https://i.loli.net/2021/07/21/v83jxduzDP4qZMQ.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第二场</title>
      <link href="/2021/07/20/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%BA%8C%E5%9C%BA/"/>
      <url>/2021/07/20/%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%BA%8C%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://i.loli.net/2021/07/20/JnGDSefc6CR1L9W.png" alt="image.png"></p><p>这次感觉除了签到题其他题都有点难下手(((</p><p>中间有个企鹅其实是广搜模拟题,调试了pyf大佬代码感觉没问题就是</p><p>超时,加快读也卡有点离谱</p><p>改用链接放题目好了,我怕图床把我照片删了TuT</p><span id="more"></span><h3 id="D题-Er-Ba-Game"><a href="#D题-Er-Ba-Game" class="headerlink" title="D题 Er Ba Game"></a>D题 Er Ba Game</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11253/D">D-Er Ba Game_2021牛客暑期多校训练营2 (nowcoder.com)</a>)</p><p>按照题意的规则进行模拟判断即可</p><p>细心就能直接a,签到题</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="C题-Draw-Grids"><a href="#C题-Draw-Grids" class="headerlink" title="C题 Draw Grids"></a>C题 Draw Grids</h3><p>&nbsp;</p><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11253/C">C-Draw Grids_2021牛客暑期多校训练营2 (nowcoder.com)</a>)</p><p>题目大意:给你一个n*m的点阵,每次只能选一个长度为1的距离连接画线</p><p>不能出现封闭图形,最后无法画线的人输</p><p>&nbsp;</p><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析:"></a>思路分析:</h4><p>不能出现封闭图形,把它看成图即不存在环,剩下的边全连上则证明要连n*m-1条边</p><p>根据n*m-1的奇偶性即可判断答案大小</p><figure class="highlight plaintext"><figcaption><span>i</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=1;i&lt;=4;i++)&#123;</span><br><span class="line">   for(int j=1;j&lt;=4;j++)&#123;</span><br><span class="line">     if((i*j-1)%2==1)&#123;</span><br><span class="line">       sg[i][j]=1;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;</p><p>&nbsp;</p><h3 id="F题-Girlfriend"><a href="#F题-Girlfriend" class="headerlink" title="F题 Girlfriend"></a>F题 Girlfriend</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11253/F">F-Girlfriend_2021牛客暑期多校训练营2 (nowcoder.com)</a>)</p><p>题目大意:根据给你四个点,和长度关系,构成两个球体,求相交面具</p><p>&nbsp;</p><p>(数学题),,不会,利用阿波罗尼斯球球壳求解</p><p>套模板了</p><p>&nbsp;</p><h3 id="K题-Stack"><a href="#K题-Stack" class="headerlink" title="K题 Stack"></a>K题 Stack</h3><p>[题目链接](<a href="https://ac.nowcoder.com/acm/contest/11253/K">K-Stack_2021牛客暑期多校训练营2 (nowcoder.com)</a>)</p><p>题目大意:有n个数，依次加进栈中，每次加入前将栈顶比ai大的所有元素弹掉，加入后记bi为栈的大小</p><p>现在给你b中的一些数，让你求a数组的一种合法方案，其中1~n在a中各出现了一次</p><p>对于输入的b,相互连接弹掉的最后一个数和当前栈顶的数,构成一个有向无环图</p><p>最后选择入度为0的点,利用拓扑跑一遍深搜,即可得到结果</p>]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>暑假集训牛客第一场</title>
      <link href="/2021/07/17/%E9%9B%86%E8%AE%AD%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%80%E5%9C%BA/"/>
      <url>/2021/07/17/%E9%9B%86%E8%AE%AD%E7%89%9B%E5%AE%A2%E7%AC%AC%E4%B8%80%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://i.loli.net/2021/07/18/Uj2EimWTcatqwBA.png" alt="image.png"></p><p><strong>暑假第一场集训结果还是满意的,虽然这英文题看得是真的累啊太难为我了</strong></p><p>这次比赛我A了D,E两题签到然后就直接去看A题的博弈了,可惜罚坐三个多小时还是没出来</p><p>好在fn 在最后十分钟暴力+神奇优化过了个H.</p><p>&nbsp;</p><span id="more"></span><h3 id="A题"><a href="#A题" class="headerlink" title="A题"></a>A题</h3><img src="https://i.loli.net/2021/07/18/hMkgf9QeoztD3WE.png" alt="image.png" style="zoom: 80%;" /><p>当时看题觉得范围N&lt;=5000,应该不难,然后模拟了前15×15发现想歪了,补了题解才知道可以直接</p><p>暴力打表…麻了</p><p>利用sg函数性质:一个情况假如无法到达先手必输的点则这个点为先手必赢,如果可以达到,则其先手</p><p>必输.题目中s为&gt;=0,故可以拿取0个,则每个行或者列中最多只有一个必输点.利用四重for循环直接模拟</p><p>即可</p><p><img src="https://i.loli.net/2021/07/18/HqDfOyS6lNc5x37.png" alt="image.png" style="zoom:80%;" />)</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="B题"><a href="#B题" class="headerlink" title="B题"></a>B题</h3><p>输入一个球的半径,和梯形的上下底,高度</p><p>判断其是否会卡住</p><p>只需判断下底是否长,不够长则一定会卡住</p><p>接着利用相似三角形即可得到结果</p><p>&nbsp;</p><h3 id="C题"><a href="#C题" class="headerlink" title="C题"></a>C题</h3><p>(不会)</p><p>&nbsp;</p><h3 id="D题"><a href="#D题" class="headerlink" title="D题"></a>D题</h3><img src="https://i.loli.net/2021/07/18/HV7uP4iOgSNrLIy.png" alt="image.png" style="zoom: 80%;" /><p>签到题,由于第二个矩阵为1行,且不可以翻转,故直接for循环遍历每一行即可</p><p>每连续的0便计数,若是超过1*m矩阵的长度x,则这段距离可以放进x+1个</p><p>累加即可得到结果</p><p>(中间没注意输入的格式,以为有空格的输入,浪费了五分钟调试,以后得注意)</p><p>关键计算代码</p><img src="https://i.loli.net/2021/07/18/vzFmPdsrTl5h6o7.png" alt="image.png" style="zoom:80%;" /><p>&nbsp;</p><h3 id="E题"><a href="#E题" class="headerlink" title="E题"></a>E题</h3><img src="https://i.loli.net/2021/07/18/dXYvjlnKPgQAD3L.png" alt="image.png" style="zoom:80%;" /><p>广搜,因为每个水管的形状不同,即使旋转只有几个方向可以选择,暂时不会..</p><p>记忆化路程选取</p><p>&nbsp;</p><h3 id="F题"><a href="#F题" class="headerlink" title="F题"></a>F题</h3><p><img src="https://i.loli.net/2021/07/18/ByAnwr8fWQ71sxS.png" alt="image.png"></p><p>&nbsp;</p><p>输入为一个字符串(前导零0也可以),要找L到R范围内满足存在各个数存在一个子串求余3为0</p><p>根据题目L与R的范围为10的18次方</p><p>分析复杂度即可猜测应该存在规律计算</p><p>由<strong>定理</strong>一个数各个位置求余的总和如果也是3的倍数,这个数是三的倍数</p><p>每一位求余三只能为0 1 2.任意三位连续的0 1 2的总都为三的倍数,故大于100的数中总是满足的</p><p>由于存在前导零我用字符串输入再转换成自然数</p><font face="黑体" size=5><p>当时没注意l,r习惯跟长度l放在一块清0,不小心将longlong重新定义为int然后白白wa了两发</p></font><img src="https://i.loli.net/2021/07/18/PENuIFWgvy8DfCQ.png" alt="image.png" style="zoom: 80%;" /><p>然后根据L,R的大小分段讨论即可累加,其中work函数为判断一个二位数以内是否存在的函数</p><img src="https://i.loli.net/2021/07/18/mZ9zDifvIw6NsUH.png" alt="image.png" style="zoom:80%;" /><p>&nbsp;</p><h3 id="G题"><a href="#G题" class="headerlink" title="G题"></a>G题</h3><img src="https://i.loli.net/2021/07/18/QKeB2zONZphlGIm.png" alt="image.png" style="zoom: 67%;" /><p>比赛的时候没开这题,看了一下直播讲解懂了一些每个数差值默认是上减下,也就是上面分配一个正号</p><p>下面分配负号.交换也可以让下面为正号,上面为负号.便可以按照这样分配正负号找到最佳结果</p><p>即让A,B数组中最大的k个数分配正号,最小的k个数分配负号</p><p>题目要求需要恰好k步,但是当n&gt;2时存在超过2个正负号,只需在这里不断来回交换即可,所以小于k次达到</p><p>的最优解和k次达到的最优解一样不影响结果.</p><p>交换后结果应该加上其绝对值差的两倍</p><p>代码:</p><img src="https://i.loli.net/2021/07/18/Q8f1nCtgLYE7lVv.png" alt="image.png" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 2021暑假集训 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二维前缀和</title>
      <link href="/2021/07/15/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2021/07/15/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>暑假时间比较多,也打算慢慢写起博客来.</p><p>刚好最近七月的校赛中有一题数字矩阵水题(不会)</p><p>二维前缀和的模板题,竟然忘记了</p><span id="more"></span><h5 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h5><p>给出一个nxn的数字矩阵，要求计算这个数字矩阵中是否存在一个子矩阵，要求这个子矩阵的行和列的长度相同，同时这个子矩阵内所有数的和为s<em>s</em>。如果存在，输出满足条件的矩阵的最小的边长，否则输出-1.</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>首先，输入两个数字n<em>n</em>和s<em>s</em>，分别表示这个矩阵的大小以及一个给定的数字s<em>s</em> (0&lt;n&lt;=1000,s&lt;=1e9)(0&lt;<em>n</em>&lt;=1000,<em>s</em>&lt;=1<em>e</em>9)</p><p>然后输入n<em>n</em>行，每行n<em>n</em>个数字，表示这个矩阵。数据保证矩阵中每个数字都在[1,1e9][1,1<em>e</em>9]</p><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>如果存在满足题目要求的子矩阵，那么请输出所有满足的子矩阵中最小的矩阵的边长，否则输出-1.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>   好吧当时以为用一维前缀和也能过,算着时间复杂度只要多加一遍i或者j的循环</p><p>   没想到果断超时,还是有漏洞.</p><p>  题目很简单就是二维的前缀和模板题</p><h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><p>由容斥必定有</p><p>sum[x, y] = sum[x - 1, y] + sum[x, y - 1] - sum[x - 1, y - 1]</p><p>则该条件一定满足于前缀表得任意元素且可以递归定义</p><p>因此, i(from 0 to n), j(from 0 to m)  sum[i, j] = sum[i - 1, j] + sum[i, j - 1] - sum[i - 1, j - 1]</p><p>只需要双重for循环即可得到</p><p>&nbsp;</p><h2 id="2-计算某个区间的总和"><a href="#2-计算某个区间的总和" class="headerlink" title="2.计算某个区间的总和"></a>2.计算某个区间的总和</h2><p>例如我们要得到(x1,y1) (x2,y2)两点到起点的和</p><p>ans=sum[x2,y2]-sum[x2,y1-1]-sum[x1-1,y2]+sum[x1,y1]</p><p>即可得到区间结果</p><p>&nbsp;</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2021/01/05/test/"/>
      <url>/2021/01/05/test/</url>
      
        <content type="html"><![CDATA[<p>just for test</p><p>&nbsp;<br>categories:</p><ul><li></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
